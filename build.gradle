import groovy.json.*
import java.util.concurrent.ConcurrentHashMap

def env = project.hasProperty('env') ? project.getProperty('env') : 'dev'
ext.env = env
logger.quiet "Loading configuration for environment [$env]."
def configFile = file("network.groovy")
def parsedConfig = new ConfigSlurper(env).parse(configFile.toURL())
ext.config = parsedConfig
ext.topology = new Topology(parsedConfig)

task findVpc(type: FindVpcTask) {
	cidrBlock = config.vpc.baseIp
	doLast {
		project.ext.vpcId = vpcId
	}
}

config.subnets.each {
	subnet ->
	config.availablityZones.eachWithIndex {
		zone, i ->
		def psubnetName = "${subnet.name}-$zone"
		task "createSubnet${psubnetName}"(type: CreateSubnet, dependsOn: findVpc) {
			cidr = "${config.vpc.baseIp}${subnet.cidrs[i]}.0/24"
			availabilityZone = zone
			subnetName = "${env}-$psubnetName"
			topology = project.topology
		}
	}
}

config.securityGroups.each {
	sg ->
	task "createSecurityGroup${sg.name}"(type: CreateSecurityGroup, dependsOn: findVpc) {
		groupName = sg.name
		description = sg.description
		doLast { logger.quiet "Added security group $sg.name" }
	}
	sg.ingressRules.eachWithIndex {
		rule, i ->
		if(rule.cidr)
		{
			task "addSecurityIngressRule${sg.name}$i"(type: AuthorizeSecurityGroupIngress, dependsOn: "createSecurityGroup${sg.name}") {
				groupName sg.name
				port = rule.port
				cidr = rule.cidr
				doLast { logger.quiet "Added ingress rule for port $port to group $sg.name" }
			}
		}
		if(rule.subnet)
		{
			// TODO add task here to create rules for subnet
		}
	}
}

task createAllSubnets(dependsOn: project.tasks.findAll { it.name.startsWith('createSubnet')}) {	
}

task createAllSecurityGroups(dependsOn: (project.tasks.findAll { it.name.startsWith('createSecurityGroup')}).add(createAllSubnets)) {
}

// ======================== Class library ==========================

class CreateSubnet extends AwsTask
{
	String vpcId
	
	@Input
	String cidr
	
	String availabilityZone
	
	@Input
	String subnetName
	
	CreateSubnet() 
	{
		onlyIf {
			println "Only If..."
			def subnets = runCommand('aws ec2 describe-subnets')
			println subnets
			def match = subnets.Subnets.find { it.CidrBlock == cidr }
			println "Match $match"
			if(match) return false
			return true
		}
	}
	
	@TaskAction
	void runTask()
	{
		vpcId = project.vpcId
		def cmd = "aws ec2 create-subnet --vpc-id $vpcId --cidr-block $cidr"
		if(availabilityZone) cmd = "$cmd --availability-zone $availabilityZone"
		def result = runCommand(cmd)
		def id = result.Subnet.SubnetId
		addTags(id, [Name: subnetName, Env: project.env])
		// get the new description with the name
		result = runCommand("aws ec2 describe-subnets --subnet-ids $id")
		topology.addSubnet result.Subnets[0]
		logger.quiet "Created subnet [$id]" 
	}
}

class AuthorizeSecurityGroupIngress extends AwsTask {
	@Input
	String groupName
	
	@Input
	String protocol = 'tcp'
	
	@Input 
	Integer port
	
	@Input 
	String cidr
	
	AuthorizeSecurityGroupIngress()
	{
		// AWS will bonk if you try to apply the same rule twice...sigh
		onlyIf {
			def group = findSecurityGroupByName(groupName)
			if(!group) return true 
			def permissions = group.IpPermissions.findAll {it.ToPort == port }.findAll {it.IpProtocol == protocol }
			if(!permissions) return true
			def match = permissions.collect { it.IpRanges.findAll { it.CidrIp == cidr }}
			if(!match) return true
			return false
		}
	}
	
	@TaskAction
	void runTask() {
		def result = runCommand("aws ec2 authorize-security-group-ingress --group-name $groupName --protocol $protocol --port $port --cidr $cidr")
	}
}

class CommandLineTask extends DefaultTask 
{
	def runCommand(String command) {
		StringBuilder errorCatcher = new StringBuilder()
		def process = command.execute()
		process.consumeProcessErrorStream(errorCatcher)
		process.waitFor()
		
		def result = process.getIn().text
	
		if(process.exitValue() != 0) {
			throw new GradleException(errorCatcher.toString())
		}
		
		def json = new JsonSlurper().parseText(result)
		return json
	}
}

class AwsTask extends CommandLineTask 
{
	Topology topology
	
	AwsTask()
	{
		group = 'AWS Tasks'
	}
	
	def findSecurityGroupByName(String name) 
	{
		try
		{
			def json = runCommand("aws ec2 describe-security-groups --group-names $name")
			return json.SecurityGroups[0]
		}
		catch(Exception)
		{
			// AWS returns non-zero exit code if it can't find any groups matching those names
			return null
		}
	}
	
	//  http://docs.aws.amazon.com/cli/latest/reference/ec2/create-security-group.html
	def createSecurityGroup(String groupName, String description, String vpcId) 
	{
		def json = runCommand("aws ec2 create-security-group --group-name $groupName --description \"${description}\" --vpc-id $vpcId")
		return json.GroupId
	}

	def findVpcId(String cidrBlock) 
	{
		def json = runCommand('aws ec2 describe-vpcs')
		def vpcId = json.Vpcs.find { it.CidrBlock.startsWith(cidrBlock)}.VpcId
		return vpcId
	}
	
	def addTags(String id, Map tags)
	{
		try 
		{
			doAddTags(id, tags)
		} 
		catch(Exception)
		{
			// Sometimes the new item isn't "ready" yet
			sleep(500)
			doAddTags(id, tags)
		}
	}
	
	private def doAddTags(String id, Map tags)
	{
		def taglist = tags.collect { "Key=$it.key,Value=$it.value" }.join(' ')
		def result = runCommand("aws ec2 create-tags --resources $id --tags $taglist")
	}
	
}

class CreateSecurityGroup extends AwsTask {
	@Input
	String groupName
	
	@Input
	String description
	
	@Input @Optional
	String vpcId
	
	String groupId
	
	CreateSecurityGroup()
	{
		onlyIf { !findSecurityGroupByName(groupName) }
	}

	@TaskAction
	void runTask() {
		vpcId = project.vpcId
		groupId = createSecurityGroup(groupName, description, vpcId)
	}
}

class FindVpcTask extends AwsTask {
	String vpcId
	
	@Input
	String cidrBlock
	
	@TaskAction
	def runTask()
	{
		vpcId = findVpcId(cidrBlock)
		logger.quiet "VPC Id is [$vpcId]"
	}
}


class Topology
{
	private IdNameMap securityGroups = new IdNameMap()
	private IdNameMap subnets = new IdNameMap()
	Map subnetConfig = [:]
	
	Topology(def config)
	{
		config.subnets.each {
			subnet ->
			def fullCidrs = subnet.cidrs.collect {
				cidr ->
				def fullCidr = config.vpc.baseIp + cidr + '.0/24'
			}
			subnetConfig[subnet.name] = [name: subnet.name, cidrs: fullCidrs]
		}
	} 
	
	void addSubnet(def subnet)
	{
		// this uses the AWS return syntax
		String name = subnet.Tags.find({ it.Key == 'Name' }).Value
		String id = subnet.SubnetId
		subnets.addItemWithValues(subnet, name, id)
	}
	
	def getSubnetByName(String name)
	{
		return subnets.getItemByName(name)
	}
	
	def getSubnetById(String id)
	{
		return subnets.getItemById(id)
	}
	
	void addSecurityGroup(def sg) 
	{
		securityGroups.addItem(sg, "GroupName", "GroupId")
	}
	
	def getSecurityGroupByName(String name)
	{
		securityGroups.getItemByName(name)
	}
	
	def getSecurityGroupById(String id)
	{
		securityGroups.getItemById(id)
	}
}

class IdNameMap
{
	def itemsById = [:] as ConcurrentHashMap
	def itemIdsByName = [:] as ConcurrentHashMap
	
	void addItem(def item, String nameKey, String idKey) 
	{
		def name = item."$namekey"
		def id = item."$idKey"
		itemsById['id'] = item
		itemIdsByName['name'] = id 	
	}
	
	void addItemWithValues(def item, String name, String id) 
	{
		itemsById['id'] = item
		itemIdsByName['name'] = id 	
	}
	
	def getItemByName(String name)
	{
		def id = itemIdsByName[name]
		return getItemById(id)
	}
	
	def getItemById(String id)
	{
		return itemsById[id]
	}
}


/*
Create a security group
aws ec2 authorize-security-group-ingress --group-id sg-903004f8 --protocol tcp --port 22 --cidr 203.0.113.0/24
aws ec2 delete-security-group --group-id sg-903004f8
*/