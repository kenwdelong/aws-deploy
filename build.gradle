import groovy.json.*
import groovy.transform.ToString
import java.nio.file.*

def env = project.hasProperty('env') ? project.getProperty('env') : 'dev'
ext.env = env

Properties p = new Properties()
String awsConfigFile = "${System.properties['user.home']}/.aws/config"
p.load(new FileReader(Paths.get(awsConfigFile).toFile()))
p.each {
	key, value ->
	ext."$key" = value
}
logger.quiet "Loaded AWS config from $awsConfigFile"


logger.quiet "Loading configuration for environment [$env]."
def configFile = file("network.groovy")
def parsedConfig = new ConfigSlurper(env).parse(configFile.toURL())
ext.config = parsedConfig

ext.topology = new Topology(parsedConfig, env)

task dummy {
	
}

task findVpc(type: FindVpcTask) {
	cidrBlock = config.vpc.baseIp
	doLast {
		project.ext.vpcId = vpcId
	}
}

topology.subnets.each {
	subnet ->
	task "createSubnet${subnet.name}"(type: CreateSubnet, dependsOn: findVpc) {
		cidr = subnet.cidr
		availabilityZone = subnet.zone
		subnetName = subnet.name
		topology = project.topology
	}
}

topology.securityGroups.each {
	sg ->
	task "createSecurityGroup${sg.name}"(type: CreateSecurityGroup, dependsOn: [findVpc, 'createAllSubnets']) {
		groupName = sg.name
		description = sg.description
		topology = project.topology
	}
	sg.ingressRules.eachWithIndex {
		rule, i ->
		task "addSecurityIngressRule${sg.name}$i"(type: AuthorizeSecurityGroupIngress, dependsOn: "createSecurityGroup${sg.name}") {
			groupName = sg.name
			port = rule.port
			cidr = rule.cidr
			topology = project.topology
			doLast { logger.quiet "Added ingress rule for port $port from $cidr to group $sg.name" }
		}
	}
}

topology.instances.eachWithIndex {
	instance, i ->
	task "runInstance$i"(type: ChefBootstrap, dependsOn: ['createAllSubnets', 'createAllSecurityGroups']) {
		ami = instance.ami
		flavor = instance.type
		securityGroupId = instance.securityGroup
		subnetId = instance.subnet
		nodeName = "server$i"
		keyPairName = instance.keyPairName
		awsAccessKey = aws_access_key_id
		awsSecretKey = aws_secret_access_key
		region = project.region
		runList = instance.runList
		sshUserName = instance.sshUser
	}
}

task createAllSubnets(dependsOn: project.tasks.findAll { it.name.startsWith('createSubnet')}) {	
}

task createAllSecurityGroups(dependsOn: (project.tasks.findAll { it.name.startsWith('addSecurityIngressRule')}) << createAllSubnets) {
}

task runAllInstances(dependsOn: (project.tasks.findAll { it.name.startsWith('runInstance')}) << createAllSecurityGroups) {
}

// ======================== Class library ==========================

class ChefBootstrap extends KnifeTask
{
	@Input
	String ami
	
	@Input
	String flavor
	
	@Input 
	String securityGroupId
	
	@Input 
	String nodeName
	
	@Input 
	String subnetId
	
	@Input 
	String keyPairName
	
	@Input
	String awsAccessKey
	
	@Input 
	String awsSecretKey
	
	@Input
	String region
	
	@Input
	String runList
	
	@Input
	String sshUserName
	
	@TaskAction
	void runTask()
	{
		def tags = "Env=${project.env}"
		def command = """knife ec2 server create -I $ami --flavor $flavor --security-group-ids $securityGroupId -N $serverName --subnet $subnetId --ssh-key $keyPairName --aws-access-key-id $awsAccessKey --aws-secret-access-key $awsSecretKey --region $region --tags $tags --run-list "$runList" -E ${project.env} -i ~/.aws/${keyPairName}.pem --associate-public-ip --ssh-user $sshUser"""
		def result = runCommand(command, new File('~/chef/chef-repo'))
		logger.quiet("Created instance $result")
	}
}

class KnifeTask extends CommandLineTask 
{
	
}

class RunInstance extends AwsTask
{
	@Input
	String ami
	
	@Input
	String type
	
	@Input 
	SecurityGroup securityGroup
	
	@Input 
	Subnet subnet
	
	@Input
	String keyPairName
	
	@TaskAction
	void runTask()
	{
		def result = runInstance(ami, type, securityGroup.id, subnet.id, keyPairName)
		println "Created instance $result.InstanceId"
	}
}

class CreateSubnet extends AwsTask
{
	String vpcId
	
	@Input
	String cidr
	
	String availabilityZone
	
	@Input
	String subnetName
	
	CreateSubnet() 
	{
		onlyIf {
			def result = findSubnets()
			def match = result.find { it.CidrBlock == cidr }
			if(match) return false
			else return true
		}
	}
	
	@TaskAction
	void runTask()
	{
		vpcId = project.vpcId
		def cmd = "aws ec2 create-subnet --vpc-id $vpcId --cidr-block $cidr"
		if(availabilityZone) cmd = "$cmd --availability-zone $availabilityZone"
		def result = runCommand(cmd)
		def id = result.Subnet.SubnetId
		topology.addIdToSubnet(subnetName, id)
		addTags(id, [Name: subnetName, Env: project.env])
		logger.quiet "Created subnet [$subnetName] with [$id]" 
	}
}

class AuthorizeSecurityGroupIngress extends AwsTask {
	@Input
	String groupName
	
	@Input
	String protocol = 'tcp'
	
	@Input 
	Integer port
	
	@Input 
	String cidr
	
	AuthorizeSecurityGroupIngress()
	{
		// AWS will bonk if you try to apply the same rule twice...sigh
		onlyIf {
			def group = findSecurityGroupByName(groupName)
			if(!group) return true
			def permissions = group.IpPermissions.findAll {it.ToPort == port }.findAll {it.IpProtocol == protocol }
			if(!permissions) return true
			def match = permissions.collect { it.IpRanges.findAll { it.CidrIp == cidr }}
			// returns an [[]] if empty
			if(!match[0]) return true
			return false
		}
	}
	
	@TaskAction
	void runTask() {
		def groupId = topology.findSecurityGroupByName(groupName).id
		def result = runCommand("aws ec2 authorize-security-group-ingress --group-id $groupId --protocol $protocol --port $port --cidr $cidr")
	}
}

class CreateSecurityGroup extends AwsTask {
	@Input
	String groupName
	
	@Input
	String description
	
	@Input @Optional
	String vpcId
	
	CreateSecurityGroup()
	{
		onlyIf { !findSecurityGroupByName(groupName) }
	}

	@TaskAction
	void runTask() 
	{
		vpcId = project.vpcId
		def groupId = createSecurityGroup(groupName, description, vpcId)
		topology.addIdToSecurityGroup(groupName, groupId)
		logger.quiet "Added security group $groupName with id $groupId" 
	}
}

class AwsTask extends CommandLineTask 
{
	Topology topology
	static def describeSecurityGroupCache
	static def describeSubnetsCache
	
	AwsTask()
	{
		group = 'AWS Tasks'
	}
	
	def findSubnets()
	{
		def json
		if(describeSubnetsCache)
		{
			json = describeSubnetsCache
		}
		else
		{
			json = runCommand('aws ec2 describe-subnets')
			describeSubnetsCache = json
			json.Subnets.each {
				subnet ->
				def name = subnet.Tags?.find { it.Key == 'Name'}?.Value
				topology.addIdToSubnet(name, subnet.SubnetId)
			}
		}
		return json.Subnets
	}
	
	def runInstance(String ami, String type, String securityGroupId, String subnetId, String keyPairName)
	{
		def json = runCommand("aws ec2 run-instances --image-id $ami --instance-type $type --key-name $keyPairName --security-group-ids $securityGroupId --subnet-id $subnetId --associate-public-ip-address")
		def instanceData = json.Instances[0]
		return instanceData
	}
	
	def findSecurityGroupByName(String name) 
	{
		def json
		if(describeSecurityGroupCache)
		{
			json = describeSecurityGroupCache
		}
		else
		{
			json = runCommand("aws ec2 describe-security-groups")
			describeSecurityGroupCache = json
			// take all the groups we have in AWS already, and record their ids.
			json.SecurityGroups.each {
				group ->
				topology.addIdToSecurityGroup(group.GroupName, group.GroupId)
			}
		}
		def match = json.SecurityGroups.find { it.GroupName == name }
		return match
	}
	
	def findSecurityGroupById(String id) 
	{
		try
		{
			def json = runCommand("aws ec2 describe-security-groups --group-ids $id")
			return json.SecurityGroups[0]
		}
		catch(Exception)
		{
			// AWS returns non-zero exit code if it can't find any groups matching those names
			return null
		}
	}
	
	//  http://docs.aws.amazon.com/cli/latest/reference/ec2/create-security-group.html
	def createSecurityGroup(String groupName, String description, String vpcId) 
	{
		def json = runCommand("aws ec2 create-security-group --group-name $groupName --description \"${description}\" --vpc-id $vpcId")
		return json.GroupId
	}

	def findVpcId(String cidrBlock) 
	{
		def json = runCommand('aws ec2 describe-vpcs')
		def vpcId = json.Vpcs.find { it.CidrBlock.startsWith(cidrBlock)}.VpcId
		return vpcId
	}
	
	def addTags(String id, Map tags)
	{
		try 
		{
			doAddTags(id, tags)
		} 
		catch(Exception)
		{
			// Sometimes the new item isn't "ready" yet
			sleep(500)
			doAddTags(id, tags)
		}
	}
	
	private def doAddTags(String id, Map tags)
	{
		def taglist = tags.collect { "Key=$it.key,Value=$it.value" }.join(' ')
		def result = runCommand("aws ec2 create-tags --resources $id --tags $taglist")
	}
	
}

class CommandLineTask extends DefaultTask 
{
	def runCommand(String command)
	{
		return runCommand(command, new File('.'))
	}

	def runCommand(String command, File dir) 
	{
		StringBuilder errorCatcher = new StringBuilder()
		StringBuilder stdOut = new StringBuilder()
		def process = command.execute([], dir)
		process.consumeProcessOutput(stdOut, errorCatcher)
		process.waitFor()
		
		if(process.exitValue() != 0) {
			throw new GradleException(errorCatcher.toString())
		}
			
		def json = new JsonSlurper().parseText(stdOut.toString())
		return json
	}
}

class FindVpcTask extends AwsTask {
	String vpcId
	
	@Input
	String cidrBlock
	
	@TaskAction
	def runTask()
	{
		vpcId = findVpcId(cidrBlock)
		logger.quiet "VPC Id is [$vpcId]"
	}
}


class Topology
{
	def subnets = []
	def securityGroups = []
	def instances = []
	
	Topology(def config, def env)
	{
		config.subnets.each {
			subnet ->
			subnet.cidrs.eachWithIndex {
				cidr, i ->
				def zone = config.availabilityZones[i]
				def c = "${config.vpc.baseIp}${cidr}.0/24"
				def name = "${env}-${subnet.name}-$zone"
				Subnet s = new Subnet(name: name, cidr: c, zone: zone)
				subnets << s
			}
		}
		//subnets.each { println it }
		
		config.securityGroups.each {
			sg ->
			def name = "${env}-$sg.name"
			SecurityGroup group = new SecurityGroup(name: name, description: sg.description)
			securityGroups << group
			
			sg.ingressRules.each {
				rule ->
				if(rule.cidr) 
				{
					IngressRule ingressRule = new IngressRule(port: rule.port, cidr: rule.cidr)
					group.ingressRules << ingressRule
				}
				if(rule.subnet)
				{
					subnets.findAll { it.name.contains(rule.subnet) }.each {
						subnet ->
						def desc = "Port $rule.port from subnet $subnet.name"
						IngressRule ingressRule = new IngressRule(port: rule.port, cidr: subnet.cidr, description: desc)
						group.ingressRules << ingressRule
					}
				}
			}
		}
		//securityGroups.each { println it }
		
		config.instances.each {
			instance ->
			def securityGroup = securityGroups.find {it.name.contains(instance.securityGroup) }
			// Put a copy in each AZ
			def targetSubnets = subnets.findAll { it.name.contains(instance.subnet)}.each {
				targetSubnet ->
				Instance i = new Instance(ami: instance.ami, keyPairName: instance.key, type: instance.type, subnet: targetSubnet, securityGroup: securityGroup,
								runList: instance.runList, sshUser: instance.sshUser)
				instances << i
			}
		}
		//instances.each { println it }
		
	} 	

	def findSubnetByName(String subnetName)
	{
		println "Looking for $subnetName"
		println "in a list of"
		subnets.each { println it }
		println "\n"
		subnets.find { it.name == subnetName }
	}
	
	def findSecurityGroupByName(String groupName)
	{
		securityGroups.find { it.name == groupName }
	}
	
	void addIdToSecurityGroup(String groupName, String id)
	{
		def group = findSecurityGroupByName(groupName)
		if(group) group.id = id
	}
	
	void addIdToSubnet(String subnetName, String id)
	{
		def subnet = findSubnetByName(subnetName)
		if(subnet) subnet.id = id
		if(subnet) println "Added id $id to $subnetName"
	}
}

@ToString
class Subnet
{
	String name
	String id
	String cidr
	String zone
}

@ToString
class SecurityGroup
{
	String name
	String id
	String description
	List<IngressRule> ingressRules = []
}

@ToString
class IngressRule
{
	Integer port
	String cidr
	String description
}

@ToString
class Instance
{
	String ami
	String keyPairName
	SecurityGroup securityGroup
	String type
	Subnet subnet
	String runList
	String sshUser
}

